from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any
import networkx as nx


@dataclass
class Subprocess:
    """Represents a component identified in a process model."""

    id: str
    name: str  # Label for the subprocess (can be generated by LLM)
    nodes: set[str] = field(default_factory=set)  # Activity/task names
    edges: set[tuple[str, str]] = field(default_factory=set)  # Connections
    metadata: dict[str, Any] = field(default_factory=dict)  # Additional info
    parent_id: str | None = None  # For hierarchical decomposition
    children_ids: list[str] = field(default_factory=list)  # Child subprocess IDs

    def to_networkx(self) -> nx.DiGraph:
        G = nx.DiGraph()
        G.add_nodes_from(self.nodes)
        G.add_edges_from(self.edges)
        return G


@dataclass
class DecompositionResult:
    """Result of a decomposition operation."""

    original_graph: nx.DiGraph
    subprocesses: list[Subprocess]
    hierarchy: dict[str, list[str]]  # parent_id -> [child_ids]
    metadata: dict[str, Any] = field(default_factory=dict)

    def get_subprocess_by_id(self, subprocess_id: str) -> Subprocess | None:
        for sp in self.subprocesses:
            if sp.id == subprocess_id:
                return sp
        return None

    def get_root_subprocesses(self) -> list[Subprocess]:
        """Get top-level subprocesses (no parent)."""
        return [sp for sp in self.subprocesses if sp.parent_id is None]


class ProcessModelAdapter(ABC):
    """Interface for adapting various process model formats to NetworkX."""

    @abstractmethod
    def load(self, source: Any) -> nx.DiGraph:
        """Load a process model and convert it to a NetworkX graph."""
        pass

    @abstractmethod
    def export(self, graph: nx.DiGraph, decomposition: DecompositionResult) -> Any:
        """Export a decomposed graph back to the original format."""
        pass

    @abstractmethod
    def get_model_type(self) -> str:
        """Return the type of model this adapter handles."""
        pass


class DecompositionStrategy(ABC):
    """Base class for process graph decomposition strategies."""

    @abstractmethod
    def decompose(self, graph: nx.DiGraph, **kwargs) -> list[Subprocess]:
        """Decompose a graph into subprocesses."""
        pass

    @abstractmethod
    def get_strategy_name(self) -> str:
        """Return the name of this decomposition strategy."""
        pass

    def decompose_hierarchical(
        self, graph: nx.DiGraph, **kwargs
    ) -> list[list[Subprocess]]:
        """
        Decompose a graph into a hierarchy of subprocess levels.

        Returns a list of levels, where each level is a list of Subprocesses.
        Default implementation returns a single level (standard decomposition).
        """
        return [self.decompose(graph, **kwargs)]


class SubprocessLabeler(ABC):
    """Interface for generating semantic labels for subprocesses."""

    @abstractmethod
    def label(self, subprocess: Subprocess, context: dict | None = None) -> str:
        """
        Generate a label/name for a subprocess.

        Args:
            subprocess: The subprocess to label
            context: Optional context information (e.g., domain knowledge)

        Returns:
            A meaningful name for the subprocess
        """
        pass
