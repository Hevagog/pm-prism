from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any
import networkx as nx


@dataclass
class Subprocess:
    """Represents a subprocess (component) identified in a process model."""

    id: str
    name: str  # Label for the subprocess (can be generated by GPT)
    nodes: set[str] = field(default_factory=set)  # Activity/task names
    edges: set[tuple[str, str]] = field(default_factory=set)  # Connections
    metadata: dict[str, Any] = field(default_factory=dict)  # Additional info
    parent_id: str | None = None  # For hierarchical decomposition
    children_ids: list[str] = field(default_factory=list)

    def to_networkx(self) -> nx.DiGraph:
        G = nx.DiGraph()
        G.add_nodes_from(self.nodes)
        G.add_edges_from(self.edges)
        return G


@dataclass
class DecompositionResult:
    """Result of a decomposition operation."""

    original_graph: nx.DiGraph
    subprocesses: list[Subprocess]
    hierarchy: dict[str, list[str]]  # parent_id -> [child_ids]
    metadata: dict[str, Any] = field(default_factory=dict)

    def get_subprocess_by_id(self, subprocess_id: str) -> Subprocess | None:
        for sp in self.subprocesses:
            if sp.id == subprocess_id:
                return sp
        return None

    def get_root_subprocesses(self) -> list[Subprocess]:
        """Get top-level subprocesses (no parent)."""
        return [sp for sp in self.subprocesses if sp.parent_id is None]


class ProcessModelAdapter(ABC):
    """
    Abstract base class for process model adapters.

    Adapters convert specific model formats (DFG, BPMN) into a common
    NetworkX-based representation for decomposition.
    """

    @abstractmethod
    def load(self, source: Any) -> nx.DiGraph:
        """
        Load a process model from a source and convert to NetworkX graph.

        Args:
            source: Model source (file path, event log, etc.)

        Returns:
            NetworkX DiGraph representation of the model
        """
        pass

    @abstractmethod
    def export(self, graph: nx.DiGraph, decomposition: DecompositionResult) -> Any:
        """
        Export a decomposed graph back to the original format.

        Args:
            graph: The NetworkX graph
            decomposition: The decomposition result

        Returns:
            Model in the original format with subprocess information
        """
        pass

    @abstractmethod
    def get_model_type(self) -> str:
        """Return the type of model this adapter handles."""
        pass


class DecompositionStrategy(ABC):
    """
    Abstract base class for decomposition strategies.

    Different strategies can be implemented:
    - Community detection (Louvain, Girvan-Newman)
    - Cut-vertex based decomposition
    - Strongly connected components
    - Domain-specific heuristics
    """

    @abstractmethod
    def decompose(self, graph: nx.DiGraph, **kwargs) -> list[Subprocess]:
        """
        Decompose a graph into subprocesses.

        Args:
            graph: NetworkX DiGraph to decompose
            **kwargs: Strategy-specific parameters

        Returns:
            List of identified subprocesses
        """
        pass

    @abstractmethod
    def get_strategy_name(self) -> str:
        """Return the name of this decomposition strategy."""
        pass


class SubprocessLabeler(ABC):
    """
    Abstract base class for subprocess labeling.

    Implementations can use GPT, simple heuristics, or other methods
    to generate meaningful names for subprocesses.
    """

    @abstractmethod
    def label(self, subprocess: Subprocess, context: dict | None  = None) -> str:
        """
        Generate a label/name for a subprocess.

        Args:
            subprocess: The subprocess to label
            context: Optional context information (e.g., domain knowledge)

        Returns:
            A meaningful name for the subprocess
        """
        pass
